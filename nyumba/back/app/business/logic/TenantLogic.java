package business.logic;

import models.persistence.Room;
import models.persistence.person.FormerTenant;
import models.persistence.person.Tenant;
import models.persistence.person.Users;
import play.Logger;
import play.db.jpa.JPAApi;
import security.Secured;
import util.Args;
import util.ClientMsg;
import util.Mapper;

import javax.inject.Inject;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;

/** This class handle logic related to tenant.
 * Created by kip on 7/21/17.
 */
public class TenantLogic {

    private static final Logger.ALogger logger = Logger.of(UserLogic.class);
    private final JPAApi jpaApi;
    private final CommonLogic commonLogic;
    private final Mapper mapper;
    private final RoomStatus roomStatus;

    @Inject
    public TenantLogic(JPAApi jpaApi, CommonLogic commonLogic, Mapper mapper, RoomStatus roomStatus){
        this.jpaApi = jpaApi; this.commonLogic = commonLogic; this.mapper = mapper; this.roomStatus = roomStatus;
    }

    public Object apply(Map<Args,Object> args) {

        Args.ACTIONS action = (Args.ACTIONS)args.get(Args.action);

        Object obj = args.get(Args.mappedObj);
        Tenant tenant = (Tenant) obj;
        Users user = commonLogic.getUser(args,jpaApi);

        //This function should be called only when we are registering a new person. Bill will be calculated.
        logger.debug("Tenant - Action: "+action);

        if(action == Args.ACTIONS.EDIT){
            if(user.getRole().equalsIgnoreCase("landlord")){

                if(tenant.getId() == null){
                    //New tenant so we assign room and update bill. The update bill logic will figure out if actually necessary to update.
                    jpaApi.em().persist(tenant);
                    tenant.setRoom(jpaApi.em().find(Room.class,tenant.getParentId()));
                    roomStatus.updateBill(tenant);
                    return tenant;
                }
                else{
                    //This is an existing tenant so we are potentially updating the tenant info
                    Tenant existingTenant = jpaApi.em().find(Tenant.class,tenant.getId());
                    existingTenant = (Tenant) this.mapper.mapFields(tenant,existingTenant);
                    return existingTenant;
                }

            }else{
                return new ClientMsg("Action not permited");
            }
        }else if(action == Args.ACTIONS.DELETE){
            if(user.getRole().equalsIgnoreCase("landlord")){
                tenant = jpaApi.em().find(Tenant.class,tenant.getId());
                FormerTenant formerTenant = new FormerTenant();
                this.mapper.mapUnrelatedObjects(tenant,formerTenant);
                formerTenant.setBuildingName(tenant.getRoom().getBuilding().getName());
                formerTenant.setRoomName(tenant.getRoom().getName());
                formerTenant.setBal(tenant.getRoom().getBills().last().getBal());
                jpaApi.em().merge(formerTenant);
                jpaApi.em().remove(tenant);
                //A null message will be interpreted on the front end as a success message, and no popup will ge generated by the mobile app.
                return new ClientMsg("deleted",obj);
            }else{
                return new ClientMsg("Action not supported");
            }
        }
        return obj;
    }

    public CompletionStage<Object> applyAsync(Map<Args, Object> args) {
        return CompletableFuture.supplyAsync(() ->  jpaApi.withTransaction(() -> this.apply(args)) );
    }
}
